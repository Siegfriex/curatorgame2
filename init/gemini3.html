
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Curator's Run v4.0 (Enhanced)</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Playfair+Display:ital,wght@1,500;1,700&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-bg: #0a0a0f;
            --color-primary: #28317C;
            --color-secondary: #3B82F6;
            --color-text: #ffffff;
            --color-accent: #3B82F6;
            --color-success: #2DD4BF;
            --color-muted: #A3A3A3;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--color-bg);
            font-family: 'Inter', sans-serif;
            touch-action: none;
            user-select: none;
        }
        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
        }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none;
        }
        
        /* Enhanced Editorial HUD with Neon Glow */
        #hud-top-left {
            position: absolute; top: 40px; left: 40px;
        }
        #hud-top-right {
            position: absolute; top: 40px; right: 40px; text-align: right;
        }
        #hud-center {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            text-align: center;
        }
        .label { 
            font-size: 10px; 
            color: var(--color-muted);
            text-transform: uppercase;
            letter-spacing: 0.25em;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }
        .value-display {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 36px;
            color: #ffffff;
            line-height: 1;
            font-weight: 500;
        }
        /* Removed pulse animation for editorial style */
        
        /* Combo Display - Editorial Style */
        #combo-display {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 36px;
            color: var(--color-muted);
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.2s ease-out;
        }
        #combo-display.active {
            opacity: 0.8;
            transform: scale(1);
        }
        #combo-display.hit {
            transform: scale(1.05);
        }
        .multiplier-badge {
            font-size: 14px;
            color: var(--color-secondary);
            margin-top: 8px;
            letter-spacing: 0.2em;
            font-weight: 600;
        }
        
        /* Hit Flash Overlay - Subtle Editorial */
        #hit-flash {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, rgba(59, 130, 246, 0.08) 0%, transparent 60%);
            opacity: 0;
            transition: opacity 0.15s ease-out;
            z-index: 5;
        }
        #hit-flash.flash {
            opacity: 1;
        }
        
        /* Gate Transition Overlay - Editorial Style */
        #gate-transition {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, rgba(40, 49, 124, 0.85) 0%, rgba(10, 10, 15, 0.98) 70%);
            opacity: 0;
            z-index: 15;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #gate-transition.active {
            opacity: 1;
        }
        #gate-transition.fade-out {
            opacity: 0;
            transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Transition Content - Editorial Style */
        .transition-label {
            font-size: 10px;
            color: var(--color-muted);
            text-transform: uppercase;
            letter-spacing: 0.3em;
            font-weight: 600;
            margin-bottom: 16px;
            opacity: 0;
            transform: translateY(20px);
            animation: slideUp 0.5s ease forwards;
            animation-delay: 0.3s;
        }
        .transition-era {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 64px;
            color: #ffffff;
            margin: 0;
            opacity: 0;
            transform: scale(0.95);
            animation: scaleIn 0.6s ease-out forwards;
            animation-delay: 0.4s;
            letter-spacing: -0.02em;
        }
        .transition-choice {
            font-size: 16px;
            color: var(--color-secondary);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-top: 24px;
            opacity: 0;
            animation: fadeIn 0.4s ease forwards;
            animation-delay: 0.6s;
        }
        .transition-choice.negative {
            color: #ff4444;
        }
        
        /* Quote reveal styling - Editorial */
        #quote-text {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.8);
            max-width: 600px;
            line-height: 1.7;
            text-align: center;
            margin-top: 32px;
            opacity: 0;
            animation: fadeIn 0.6s ease forwards;
            animation-delay: 0.8s;
        }
        #quote-author {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            color: rgba(59, 130, 246, 0.9);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-top: 16px;
            opacity: 0;
            animation: fadeIn 0.5s ease forwards;
            animation-delay: 1.0s;
        }
        
        @keyframes slideUp {
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes scaleIn {
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        /* Speed lines effect during transition */
        .speed-lines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            overflow: hidden;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
        }
        .speed-line {
            position: absolute;
            background: linear-gradient(to bottom, transparent 0%, rgba(59, 130, 246, 0.8) 50%, transparent 100%);
            width: 2px;
            height: 100%;
            animation: speedLine 0.5s linear infinite;
        }
        @keyframes speedLine {
            from { transform: translateY(-100%); }
            to { transform: translateY(100%); }
        }
        
        /* Game Over Screen - Editorial Style */
        #game-over {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            background: rgba(10, 10, 15, 0.98);
            padding: 48px 64px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 30px 60px rgba(0,0,0, 0.6);
            width: 380px;
            max-width: 90%;
            z-index: 20;
            color: #fff;
        }
        #game-over h1 {
            color: #fff;
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 32px;
            font-weight: 400;
            margin: 0 0 24px 0;
            letter-spacing: -0.02em;
        }
        .path-list {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid rgba(255,255,255,0.1);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 15px 0;
        }
        .path-step {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #888;
            font-weight: 700;
        }
        button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 14px 28px;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            transition: all 0.3s ease;
        }
        button:hover { 
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        /* Mobile Controls */
        #mobile-controls {
            display: none; position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; pointer-events: auto;
        }
        #joystick-zone {
            position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px;
            border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 50%;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.2);
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            background: rgba(59, 130, 246, 0.3); backdrop-filter: blur(4px);
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }
        
        /* Input Mode Indicator */
        #input-indicator {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 24px;
            background: rgba(10, 10, 30, 0.9);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.2);
        }
        #input-indicator:hover {
            border-color: rgba(59, 130, 246, 0.6);
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.4);
        }
        .input-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .input-icon svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }
        .input-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }
        .input-mode {
            font-size: 12px;
            color: #3B82F6;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        #input-indicator.mediapipe .input-mode { color: #2DD4BF; }
        #input-indicator.mediapipe .input-icon { color: #2DD4BF; }
        #input-indicator.keyboard .input-mode { color: #3B82F6; }
        #input-indicator.keyboard .input-icon { color: #3B82F6; }
        #input-indicator.loading .input-mode { color: #ffaa00; }
        
        /* Webcam Preview (small) */
        #webcam-container {
            position: absolute;
            bottom: 100px;
            right: 40px;
            width: 160px;
            height: 120px;
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            overflow: hidden;
            display: none;
            opacity: 0.7;
            transition: opacity 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #webcam-container:hover {
            opacity: 1;
        }
        #webcam-container.active {
            display: block;
        }
        #webcam-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror for intuitive control */
        }
        #webcam-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
        .webcam-label {
            position: absolute;
            top: 8px;
            left: 8px;
            font-size: 8px;
            color: #2DD4BF;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        /* Hand Position Indicator */
        #hand-indicator {
            position: absolute;
            bottom: 40px;
            right: 220px;
            width: 180px;
            height: 30px;
            background: rgba(10, 10, 30, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 4px;
            overflow: hidden;
            display: none;
        }
        #hand-indicator.active {
            display: block;
        }
        #hand-indicator-fill {
            position: absolute;
            top: 0;
            left: 50%;
            height: 100%;
            width: 10px;
            background: linear-gradient(90deg, transparent, #2DD4BF, transparent);
            transform: translateX(-50%);
            transition: left 0.05s ease-out;
        }
        #hand-indicator-center {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(-50%);
        }
        
        /* Audio Toggle Button */
        #audio-toggle {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 44px;
            height: 44px;
            background: rgba(10, 10, 30, 0.9);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s ease;
            color: #3B82F6;
        }
        #audio-toggle:hover {
            border-color: rgba(59, 130, 246, 0.6);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }
        #audio-toggle.muted {
            color: #ff4444;
            border-color: rgba(255, 68, 68, 0.3);
        }
        #audio-toggle svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }
        
        /* Beat Indicator */
        #beat-indicator {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 16px;
            background: rgba(59, 130, 246, 0.3);
            border-radius: 50%;
            transition: all 0.1s ease;
        }
        #beat-indicator.beat {
            background: rgba(59, 130, 246, 1);
            transform: translateX(-50%) scale(1.3);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.min.js" crossorigin="anonymous"></script>
    
    <!-- Tone.js for Audio/Rhythm System -->
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="hit-flash"></div>
    
    <!-- Gate Transition Overlay -->
    <div id="gate-transition">
        <div class="speed-lines" id="speed-lines"></div>
        <div class="transition-label" id="transition-label">Entering New Era</div>
        <div class="transition-era" id="transition-era">20s</div>
        <div class="transition-choice" id="transition-choice">Path: ELITE</div>
        <div id="quote-text"></div>
        <div id="quote-author"></div>
    </div>

    <div id="ui-layer">
        <div id="hud-top-left">
            <div class="label">Era</div>
            <div class="value-display" id="era-display">10s</div>
        </div>
        <div id="hud-top-right">
            <div class="label">Collected</div>
            <div class="value-display" id="score-val">0</div>
        </div>
        <div id="hud-center">
            <div id="combo-display">0</div>
            <div class="multiplier-badge" id="multiplier-display"></div>
        </div>
        
        <div id="game-over">
            <h1>Journey Complete</h1>
            <div class="label">Path Taken</div>
            <div class="path-list" id="path-results"></div>
            <div class="label" style="margin-top: 20px;">Artifacts</div>
            <div id="final-score" style="font-family: 'Playfair Display'; font-size: 28px; margin-bottom: 10px; color: #ffffff;">0</div>
            <div class="label">Best Momentum</div>
            <div id="final-combo" style="font-family: 'Playfair Display'; font-size: 18px; margin-bottom: 30px; color: #A3A3A3;">0</div>
            <button id="restart-btn">Begin Again</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
    </div>
    
    <!-- Input Mode Indicator -->
    <div id="input-indicator" class="keyboard">
        <div class="input-icon">
            <svg id="icon-keyboard" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M20 5H4c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z"/>
            </svg>
            <svg id="icon-hand" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                <path d="M18 12c-.26 0-.5.03-.76.08L15 10.66V5c0-1.1-.9-2-2-2s-2 .9-2 2v5.82l-1.52-.76c-.53-.27-1.16-.4-1.78-.4-1.17 0-2.31.46-3.15 1.29l-1.84 1.84L8.97 19h8.06c.93 0 1.75-.54 2.13-1.37l2.39-5.36c.15-.35.25-.73.25-1.12 0-1.1-.9-2.15-2-2.15z"/>
            </svg>
        </div>
        <div>
            <div class="input-label">Input Mode</div>
            <div class="input-mode" id="input-mode-text">Keyboard</div>
        </div>
    </div>
    
    <!-- Webcam Preview -->
    <div id="webcam-container">
        <video id="webcam-video" autoplay playsinline></video>
        <canvas id="webcam-canvas"></canvas>
        <div class="webcam-label">Hand Tracking</div>
    </div>
    
    <!-- Hand Position Indicator -->
    <div id="hand-indicator">
        <div id="hand-indicator-center"></div>
        <div id="hand-indicator-fill"></div>
    </div>
    
    <!-- Audio Toggle Button -->
    <div id="audio-toggle">
        <svg id="audio-on-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
        <svg id="audio-off-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="display: none;">
            <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
        </svg>
    </div>
    
    <!-- Beat Indicator -->
    <div id="beat-indicator"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ============================================================
        // PHASE 1.3: COMBO SYSTEM
        // ============================================================
        const comboSystem = {
            combo: 0,
            multiplier: 1,
            maxCombo: 0,
            lastHitTime: 0,
            
            addHit() {
                this.combo++;
                this.lastHitTime = Date.now();
                if (this.combo > this.maxCombo) this.maxCombo = this.combo;
                
                // Update multiplier based on combo thresholds
                if (this.combo > 30) this.multiplier = 8;
                else if (this.combo > 20) this.multiplier = 4;
                else if (this.combo > 10) this.multiplier = 2;
                else this.multiplier = 1;
                
                this.updateUI();
                return this.multiplier;
            },
            
            resetCombo() {
                if (this.combo > 5) {
                    // Only play miss sound if we had a decent combo
                    if (typeof audioSystem !== 'undefined') {
                        audioSystem.playMissSound();
                    }
                }
                this.combo = 0;
                this.multiplier = 1;
                this.updateUI();
            },
            
            getScore(basePoints) {
                return basePoints * this.multiplier;
            },
            
            updateUI() {
                const comboEl = document.getElementById('combo-display');
                const multEl = document.getElementById('multiplier-display');
                
                if (this.combo > 0) {
                    comboEl.textContent = this.combo;
                    comboEl.classList.add('active', 'hit');
                    setTimeout(() => comboEl.classList.remove('hit'), 100);
                    
                    // Color based on multiplier - editorial palette
                    if (this.multiplier >= 8) comboEl.style.color = '#818CF8';
                    else if (this.multiplier >= 4) comboEl.style.color = '#3B82F6';
                    else if (this.multiplier >= 2) comboEl.style.color = '#2DD4BF';
                    else comboEl.style.color = '#A3A3A3';
                    
                    // Editorial style: plus signs instead of multiplier
                    multEl.textContent = '+'.repeat(Math.min(this.multiplier, 5));
                } else {
                    comboEl.classList.remove('active');
                }
            },
            
            // Decay combo if no hits for 2 seconds
            update() {
                if (this.combo > 0 && Date.now() - this.lastHitTime > 2000) {
                    this.resetCombo();
                }
            }
        };

        // ============================================================
        // PHASE 4.2: DUAL INPUT SYSTEM (MediaPipe + Keyboard)
        // ============================================================
        class DualInputSystem {
            constructor() {
                this.activeMode = 'keyboard';  // 'keyboard' | 'mediapipe' | 'loading'
                this.handPosition = { x: 0, y: 0, confidence: 0 };
                this.keyboardInput = 0;
                this.smoothedHandX = 0;
                this.isMediaPipeAvailable = false;
                this.hands = null;
                this.camera = null;
                
                // UI Elements
                this.indicatorEl = document.getElementById('input-indicator');
                this.modeTextEl = document.getElementById('input-mode-text');
                this.webcamContainer = document.getElementById('webcam-container');
                this.handIndicator = document.getElementById('hand-indicator');
                this.handIndicatorFill = document.getElementById('hand-indicator-fill');
                this.iconKeyboard = document.getElementById('icon-keyboard');
                this.iconHand = document.getElementById('icon-hand');
                
                // Bind methods
                this.onHandResults = this.onHandResults.bind(this);
                
                // Setup
                this.setupKeyboard();
                this.setupModeToggle();
            }
            
            setupKeyboard() {
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                        this.keyboardInput = -1;
                    }
                    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                        this.keyboardInput = 1;
                    }
                    // Press 'H' to toggle hand tracking
                    if (e.key === 'h' || e.key === 'H') {
                        this.toggleMode();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A' ||
                        e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                        this.keyboardInput = 0;
                    }
                });
            }
            
            setupModeToggle() {
                this.indicatorEl.addEventListener('click', () => {
                    this.toggleMode();
                });
            }
            
            async toggleMode() {
                if (this.activeMode === 'keyboard') {
                    await this.enableMediaPipe();
                } else {
                    this.disableMediaPipe();
                }
            }
            
            async enableMediaPipe() {
                // Check if MediaPipe is available
                if (typeof window.Hands === 'undefined') {
                    console.warn('MediaPipe Hands not loaded');
                    this.updateUI('keyboard');
                    return;
                }
                
                this.updateUI('loading');
                
                try {
                    const videoEl = document.getElementById('webcam-video');
                    const canvasEl = document.getElementById('webcam-canvas');
                    const canvasCtx = canvasEl.getContext('2d');
                    
                    // Initialize MediaPipe Hands
                    this.hands = new window.Hands({
                        locateFile: (file) => {
                            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
                        }
                    });
                    
                    this.hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 0,  // 0 = Lite (faster)
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    this.hands.onResults((results) => {
                        this.onHandResults(results, canvasEl, canvasCtx);
                    });
                    
                    // Request camera access
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            width: 320, 
                            height: 240,
                            facingMode: 'user'
                        }
                    });
                    
                    videoEl.srcObject = stream;
                    await videoEl.play();
                    
                    // Set canvas size
                    canvasEl.width = videoEl.videoWidth || 320;
                    canvasEl.height = videoEl.videoHeight || 240;
                    
                    // Start camera processing
                    this.camera = new window.Camera(videoEl, {
                        onFrame: async () => {
                            if (this.hands && this.activeMode === 'mediapipe') {
                                await this.hands.send({ image: videoEl });
                            }
                        },
                        width: 320,
                        height: 240
                    });
                    
                    await this.camera.start();
                    
                    this.isMediaPipeAvailable = true;
                    this.activeMode = 'mediapipe';
                    this.updateUI('mediapipe');
                    
                    console.log('MediaPipe hand tracking enabled');
                    
                } catch (error) {
                    console.error('Failed to enable MediaPipe:', error);
                    this.updateUI('keyboard');
                    this.activeMode = 'keyboard';
                    
                    // Show user-friendly message
                    if (error.name === 'NotAllowedError') {
                        alert('Camera access denied. Using keyboard controls.\n\nPress A/D or Arrow Keys to move.');
                    }
                }
            }
            
            disableMediaPipe() {
                this.activeMode = 'keyboard';
                this.updateUI('keyboard');
                
                // Stop camera
                if (this.camera) {
                    this.camera.stop();
                    this.camera = null;
                }
                
                // Stop video stream
                const videoEl = document.getElementById('webcam-video');
                if (videoEl && videoEl.srcObject) {
                    const tracks = videoEl.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    videoEl.srcObject = null;
                }
                
                // Close hands
                if (this.hands) {
                    this.hands.close();
                    this.hands = null;
                }
                
                this.handPosition = { x: 0, y: 0, confidence: 0 };
                this.smoothedHandX = 0;
                
                console.log('MediaPipe disabled, using keyboard');
            }
            
            onHandResults(results, canvasEl, canvasCtx) {
                // Clear canvas
                canvasCtx.clearRect(0, 0, canvasEl.width, canvasEl.height);
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // Draw hand landmarks
                    if (window.drawConnectors && window.drawLandmarks) {
                        window.drawConnectors(canvasCtx, landmarks, window.HAND_CONNECTIONS, {
                            color: '#2DD4BF',
                            lineWidth: 2
                        });
                        window.drawLandmarks(canvasCtx, landmarks, {
                            color: '#3B82F6',
                            lineWidth: 1,
                            radius: 3
                        });
                    }
                    
                    // Get palm center (landmark 9 - middle finger base)
                    const palmCenter = landmarks[9];
                    
                    // Also consider wrist (0) for stability
                    const wrist = landmarks[0];
                    
                    // Average for more stable tracking
                    const handX = (palmCenter.x + wrist.x) / 2;
                    const handY = (palmCenter.y + wrist.y) / 2;
                    
                    // Update hand position (normalize to -1 to 1)
                    // Note: x is inverted because video is mirrored
                    const normalizedX = (handX - 0.5) * 2;  // -1 (left) to 1 (right)
                    
                    this.handPosition = {
                        x: normalizedX,
                        y: (handY - 0.5) * 2,
                        confidence: results.multiHandedness?.[0]?.score || 0.8
                    };
                    
                    // Update hand indicator
                    const indicatorX = 50 + (normalizedX * 45); // 5% to 95%
                    this.handIndicatorFill.style.left = `${indicatorX}%`;
                    
                } else {
                    // No hand detected - gradually return to center
                    this.handPosition.confidence *= 0.9;
                    if (this.handPosition.confidence < 0.1) {
                        this.handPosition = { x: 0, y: 0, confidence: 0 };
                    }
                }
            }
            
            updateUI(mode) {
                this.indicatorEl.className = mode;
                
                switch (mode) {
                    case 'mediapipe':
                        this.modeTextEl.textContent = 'Hand Tracking';
                        this.iconKeyboard.style.display = 'none';
                        this.iconHand.style.display = 'block';
                        this.webcamContainer.classList.add('active');
                        this.handIndicator.classList.add('active');
                        break;
                    case 'loading':
                        this.modeTextEl.textContent = 'Loading...';
                        this.iconKeyboard.style.display = 'none';
                        this.iconHand.style.display = 'block';
                        break;
                    case 'keyboard':
                    default:
                        this.modeTextEl.textContent = 'Keyboard (A/D)';
                        this.iconKeyboard.style.display = 'block';
                        this.iconHand.style.display = 'none';
                        this.webcamContainer.classList.remove('active');
                        this.handIndicator.classList.remove('active');
                        break;
                }
            }
            
            getInput() {
                if (this.activeMode === 'mediapipe' && this.handPosition.confidence > 0.3) {
                    // Smooth hand input
                    const targetX = this.handPosition.x;
                    this.smoothedHandX += (targetX - this.smoothedHandX) * 0.3;
                    
                    // Dead zone in center
                    const deadZone = 0.15;
                    if (Math.abs(this.smoothedHandX) < deadZone) {
                        return 0;
                    }
                    
                    // Scale and clamp
                    const input = this.smoothedHandX > 0 
                        ? (this.smoothedHandX - deadZone) / (1 - deadZone)
                        : (this.smoothedHandX + deadZone) / (1 - deadZone);
                    
                    return Math.max(-1, Math.min(1, input * 1.5));
                }
                
                // Fallback to keyboard
                return this.keyboardInput;
            }
            
            destroy() {
                this.disableMediaPipe();
            }
        }
        
        // Initialize input system
        const inputSystem = new DualInputSystem();

        // ============================================================
        // PHASE 5: AUDIO/RHYTHM SYSTEM (Tone.js)
        // ============================================================
        class AudioSystem {
            constructor() {
                this.isInitialized = false;
                this.isEnabled = true;
                this.bpm = 120;
                
                // Synths for hit sounds
                this.perfectSynth = null;
                this.goodSynth = null;
                this.missSynth = null;
                this.collectSynth = null;
                
                // Background music
                this.bgMusic = null;
                this.bgMusicPlaying = false;
                
                // Effects
                this.reverb = null;
                this.delay = null;
                this.filter = null;
                
                // Beat tracking
                this.beatCallback = null;
                this.lastBeat = 0;
            }
            
            async initialize() {
                if (this.isInitialized || typeof Tone === 'undefined') return;
                
                try {
                    // Start audio context on user interaction
                    await Tone.start();
                    console.log('Audio context started');
                    
                    // Create effects chain
                    this.reverb = new Tone.Reverb({
                        decay: 1.5,
                        wet: 0.3
                    }).toDestination();
                    
                    this.delay = new Tone.FeedbackDelay({
                        delayTime: '8n',
                        feedback: 0.2,
                        wet: 0.15
                    }).connect(this.reverb);
                    
                    this.filter = new Tone.Filter({
                        frequency: 5000,
                        type: 'lowpass'
                    }).connect(this.delay);
                    
                    // Perfect hit - bright, resonant synth
                    this.perfectSynth = new Tone.Synth({
                        oscillator: { type: 'triangle8' },
                        envelope: {
                            attack: 0.005,
                            decay: 0.2,
                            sustain: 0.1,
                            release: 0.3
                        }
                    }).connect(this.filter);
                    
                    // Good hit - softer pluck
                    this.goodSynth = new Tone.PluckSynth({
                        attackNoise: 2,
                        dampening: 4000,
                        resonance: 0.9
                    }).connect(this.filter);
                    
                    // Miss - noise burst
                    this.missSynth = new Tone.NoiseSynth({
                        noise: { type: 'pink' },
                        envelope: {
                            attack: 0.005,
                            decay: 0.15,
                            sustain: 0
                        }
                    });
                    this.missSynth.volume.value = -15;
                    this.missSynth.toDestination();
                    
                    // Artifact collect - sparkle arpeggio
                    this.collectSynth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'sine' },
                        envelope: {
                            attack: 0.01,
                            decay: 0.3,
                            sustain: 0,
                            release: 0.2
                        }
                    });
                    this.collectSynth.volume.value = -8;
                    this.collectSynth.connect(this.filter);
                    
                    // Background ambient music
                    this.createBackgroundMusic();
                    
                    // Set BPM
                    Tone.Transport.bpm.value = this.bpm;
                    
                    this.isInitialized = true;
                    console.log('Audio system initialized');
                    
                } catch (error) {
                    console.warn('Failed to initialize audio:', error);
                }
            }
            
            createBackgroundMusic() {
                // Ambient pad synth
                const padSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'sine' },
                    envelope: {
                        attack: 2,
                        decay: 1,
                        sustain: 0.8,
                        release: 3
                    }
                });
                padSynth.volume.value = -20;
                
                const padReverb = new Tone.Reverb({
                    decay: 4,
                    wet: 0.6
                }).toDestination();
                
                padSynth.connect(padReverb);
                
                // Deep bass
                const bassSynth = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: {
                        attack: 0.5,
                        decay: 0.5,
                        sustain: 0.5,
                        release: 1
                    }
                });
                bassSynth.volume.value = -18;
                bassSynth.toDestination();
                
                // Arpeggiator pattern
                const arpeggioSynth = new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: {
                        attack: 0.01,
                        decay: 0.2,
                        sustain: 0,
                        release: 0.3
                    }
                });
                arpeggioSynth.volume.value = -22;
                arpeggioSynth.connect(this.delay);
                
                // Chord progression (Am - F - C - G) in 2 bars each
                const chords = [
                    ['A3', 'C4', 'E4'],  // Am
                    ['F3', 'A3', 'C4'],  // F
                    ['C3', 'E3', 'G3'],  // C
                    ['G3', 'B3', 'D4']   // G
                ];
                
                const bassNotes = ['A2', 'F2', 'C2', 'G2'];
                const arpeggioNotes = [
                    ['A4', 'C5', 'E5', 'A5'],
                    ['F4', 'A4', 'C5', 'F5'],
                    ['C4', 'E4', 'G4', 'C5'],
                    ['G4', 'B4', 'D5', 'G5']
                ];
                
                let chordIndex = 0;
                
                // Pad pattern (whole notes)
                const padPart = new Tone.Loop((time) => {
                    padSynth.triggerAttackRelease(chords[chordIndex], '2n', time);
                }, '2n');
                
                // Bass pattern
                const bassPart = new Tone.Loop((time) => {
                    bassSynth.triggerAttackRelease(bassNotes[chordIndex], '2n', time);
                }, '2n');
                
                // Arpeggio pattern (8th notes)
                let arpIndex = 0;
                const arpPart = new Tone.Loop((time) => {
                    const notes = arpeggioNotes[chordIndex];
                    arpeggioSynth.triggerAttackRelease(notes[arpIndex % notes.length], '16n', time);
                    arpIndex++;
                }, '8n');
                
                // Chord change (every 2 bars)
                const chordChange = new Tone.Loop((time) => {
                    chordIndex = (chordIndex + 1) % chords.length;
                    arpIndex = 0;
                }, '1m');
                
                // Beat callback for game sync
                const beatLoop = new Tone.Loop((time) => {
                    if (this.beatCallback) {
                        Tone.Draw.schedule(() => {
                            this.beatCallback();
                        }, time);
                    }
                    this.lastBeat = Tone.now();
                }, '4n');
                
                this.bgMusic = {
                    padPart,
                    bassPart,
                    arpPart,
                    chordChange,
                    beatLoop,
                    padSynth,
                    bassSynth,
                    arpeggioSynth
                };
            }
            
            startBackgroundMusic() {
                if (!this.isInitialized || this.bgMusicPlaying || !this.bgMusic) return;
                
                this.bgMusic.padPart.start(0);
                this.bgMusic.bassPart.start(0);
                this.bgMusic.arpPart.start(0);
                this.bgMusic.chordChange.start(0);
                this.bgMusic.beatLoop.start(0);
                
                Tone.Transport.start();
                this.bgMusicPlaying = true;
                
                console.log('Background music started');
            }
            
            stopBackgroundMusic() {
                if (!this.bgMusic) return;
                
                this.bgMusic.padPart.stop();
                this.bgMusic.bassPart.stop();
                this.bgMusic.arpPart.stop();
                this.bgMusic.chordChange.stop();
                this.bgMusic.beatLoop.stop();
                
                Tone.Transport.stop();
                this.bgMusicPlaying = false;
            }
            
            // Play sounds for artifact collection
            playCollectSound(tier, combo = 1) {
                if (!this.isInitialized || !this.isEnabled) return;
                
                // Different notes based on tier
                const baseNote = tier === 1 ? 'C5' : tier === 2 ? 'E5' : 'G5';
                const notes = [baseNote];
                
                // Add harmonic based on combo
                if (combo > 5) notes.push(Tone.Frequency(baseNote).transpose(4).toNote());
                if (combo > 15) notes.push(Tone.Frequency(baseNote).transpose(7).toNote());
                if (combo > 25) notes.push(Tone.Frequency(baseNote).transpose(12).toNote());
                
                this.collectSynth.triggerAttackRelease(notes, '16n');
            }
            
            // Perfect hit - on beat
            playPerfectHit() {
                if (!this.isInitialized || !this.isEnabled) return;
                
                // High resonant note
                this.perfectSynth.triggerAttackRelease('C6', '16n');
            }
            
            // Good hit
            playGoodHit() {
                if (!this.isInitialized || !this.isEnabled) return;
                
                this.goodSynth.triggerAttackRelease('A4', '16n');
            }
            
            // Miss
            playMissSound() {
                if (!this.isInitialized || !this.isEnabled) return;
                
                this.missSynth.triggerAttackRelease('8n');
            }
            
            // Gate enter - dramatic sound
            playGateSound(isNegative = false) {
                if (!this.isInitialized || !this.isEnabled) return;
                
                const synth = new Tone.Synth({
                    oscillator: { type: 'sawtooth' },
                    envelope: {
                        attack: 0.1,
                        decay: 0.5,
                        sustain: 0.3,
                        release: 1
                    }
                });
                synth.volume.value = -12;
                
                const filter = new Tone.Filter({
                    frequency: isNegative ? 300 : 800,
                    type: 'lowpass'
                }).toDestination();
                
                synth.connect(filter);
                
                const note = isNegative ? 'D2' : 'C3';
                synth.triggerAttackRelease(note, '2n');
                
                // Swoosh effect
                filter.frequency.rampTo(isNegative ? 100 : 2000, 0.5);
                
                // Cleanup
                setTimeout(() => {
                    synth.dispose();
                    filter.dispose();
                }, 3000);
            }
            
            // Era transition fanfare
            playEraFanfare(eraIndex) {
                if (!this.isInitialized || !this.isEnabled) return;
                
                const notes = [
                    ['C4', 'E4', 'G4', 'C5'],  // Era 1 -> 2
                    ['D4', 'F#4', 'A4', 'D5'], // Era 2 -> 3
                    ['E4', 'G#4', 'B4', 'E5']  // Era 3 -> Legend
                ];
                
                const fanfareNotes = notes[Math.min(eraIndex, 2)];
                
                fanfareNotes.forEach((note, i) => {
                    setTimeout(() => {
                        this.perfectSynth.triggerAttackRelease(note, '8n');
                    }, i * 150);
                });
            }
            
            // Set beat callback for rhythm sync
            onBeat(callback) {
                this.beatCallback = callback;
            }
            
            // Check if we're on beat (within tolerance)
            isOnBeat(toleranceMs = 100) {
                if (!this.isInitialized) return false;
                
                const now = Tone.now() * 1000;
                const beatInterval = (60 / this.bpm) * 1000;
                const lastBeatMs = this.lastBeat * 1000;
                const timeSinceLastBeat = now - lastBeatMs;
                
                return timeSinceLastBeat < toleranceMs || 
                       (beatInterval - timeSinceLastBeat) < toleranceMs;
            }
            
            toggleEnabled() {
                this.isEnabled = !this.isEnabled;
                
                if (this.isEnabled) {
                    if (this.bgMusicPlaying) {
                        Tone.Transport.start();
                    }
                } else {
                    Tone.Transport.pause();
                }
                
                return this.isEnabled;
            }
            
            dispose() {
                this.stopBackgroundMusic();
                
                if (this.perfectSynth) this.perfectSynth.dispose();
                if (this.goodSynth) this.goodSynth.dispose();
                if (this.missSynth) this.missSynth.dispose();
                if (this.collectSynth) this.collectSynth.dispose();
                if (this.reverb) this.reverb.dispose();
                if (this.delay) this.delay.dispose();
                if (this.filter) this.filter.dispose();
                
                if (this.bgMusic) {
                    Object.values(this.bgMusic).forEach(item => {
                        if (item && item.dispose) item.dispose();
                    });
                }
            }
        }
        
        // Initialize audio system
        const audioSystem = new AudioSystem();
        
        // Initialize audio on first user interaction
        const initAudioOnInteraction = async () => {
            await audioSystem.initialize();
            audioSystem.startBackgroundMusic();
            
            // Remove listeners after init
            document.removeEventListener('click', initAudioOnInteraction);
            document.removeEventListener('keydown', initAudioOnInteraction);
            document.removeEventListener('touchstart', initAudioOnInteraction);
        };
        
        document.addEventListener('click', initAudioOnInteraction);
        document.addEventListener('keydown', initAudioOnInteraction);
        document.addEventListener('touchstart', initAudioOnInteraction);

        // ============================================================
        // PROCEDURAL TEXTURES
        // ============================================================
        function createMapTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#050510'; 
            ctx.fillRect(0, 0, 1024, 1024);
            
            // Grid Lines
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.1)';
            ctx.lineWidth = 1;
            for(let i=0; i<1024; i+=32) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 1024); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(1024, i); ctx.stroke();
            }

            // Isolines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            for(let j=0; j<8; j++) {
                ctx.beginPath();
                let startY = Math.random()*1024;
                ctx.moveTo(0, startY);
                for(let i=0; i<=1024; i+=50) {
                     ctx.lineTo(i, startY + Math.sin(i*0.01 + j)*100 + (Math.random()-0.5)*50);
                }
                ctx.stroke();
            }

            // Compass Rose
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
            ctx.beginPath(); ctx.arc(512, 512, 200, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.arc(512, 512, 180, 0, Math.PI*2); ctx.stroke();
            ctx.setLineDash([15, 15]);
            ctx.beginPath(); ctx.arc(512, 512, 250, 0, Math.PI*2); ctx.stroke();
            ctx.setLineDash([]);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createTextTexture(text, isNegative = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            const bgColor = isNegative ? 'rgba(85, 0, 0, 0.9)' : 'rgba(10, 10, 40, 0.9)';
            const borderColor = isNegative ? '#ff4444' : '#3B82F6';
            
            ctx.fillStyle = bgColor;
            ctx.fillRect(20, 20, 472, 88);
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 3;
            ctx.strokeRect(20, 20, 472, 88);
            
            // Glow effect
            ctx.shadowColor = borderColor;
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 40px "Playfair Display", serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);
            
            return new THREE.CanvasTexture(canvas);
        }

        // ============================================================
        // CONSTANTS
        // ============================================================
        const COLORS = {
            INSTITUTION: 0x28317C,
            ACADEMIC: 0xE5E5E5,
            DISCOURSE: 0xFFFFFF,
            NETWORK: 0x3B82F6,
            BG: 0x0a0a0f,
            WATER: 0x0a1a3a,
            ACCENT: 0x3B82F6
        };

        const DIRECTIONS = {
            UP: { rotation: Math.PI, vector: new THREE.Vector3(0, 1, 0) },
            DOWN: { rotation: 0, vector: new THREE.Vector3(0, -1, 0) },
            LEFT: { rotation: Math.PI / 2, vector: new THREE.Vector3(-1, 0, 0) },
            RIGHT: { rotation: -Math.PI / 2, vector: new THREE.Vector3(1, 0, 0) },
            ANY: { rotation: 0, vector: new THREE.Vector3(0, 0, 0) }
        };
        const DIRECTION_KEYS = Object.keys(DIRECTIONS);

        const ERAS = ['10s', '20s', '30s', 'LEGEND'];
        const GATE_DATA = {
            '10s': [{l:'SCANDAL',t:'n'}, {l:'ELITE',t:'p'}, {l:'VIRAL',t:'u'}],
            '20s': [{l:'EXPULSION',t:'n'}, {l:'ACCLAIM',t:'p'}, {l:'RESIDENCY',t:'p'}],
            '30s': [{l:'CENSOR',t:'n'}, {l:'MUSEUM',t:'p'}, {l:'BIENNALE',t:'p'}]
        };
        
        // ============================================================
        // REVEAL INFO: Hidden gate quotes (shown on entry)
        // ============================================================
        const REVEAL_INFO = {
            SCANDAL: {
                title: 'SCANDAL', tone: 'n',
                quotes: [
                    { ko: '        .', en: 'The only thing worse than being talked about is not being talked about.', by: 'Oscar Wilde, 1890' },
                    { ko: '     .', en: 'Scandal is gossip made tedious by morality.', by: 'Oscar Wilde, 1892' }
                ]
            },
            ELITE: {
                title: 'ELITE', tone: 'p',
                quotes: [
                    { ko: '       .', en: 'There is a natural aristocracy among men, founded on virtue and talents.', by: 'Thomas Jefferson, 1813' },
                    { ko: '  .     .', en: 'All animals are equal, but some animals are more equal than others.', by: 'George Orwell, 1945' }
                ]
            },
            VIRAL: {
                title: 'VIRAL', tone: 'u',
                quotes: [
                    { ko: '  15     .', en: 'In the future, everyone will be world-famous for 15 minutes.', by: 'Andy Warhol, 1968' },
                    { ko: '   .', en: 'Social media is the ultimate equalizer.', by: 'Amy Jo Martin' }
                ]
            },
            EXPULSION: {
                title: 'EXPULSION', tone: 'n',
                quotes: [
                    { ko: '   .', en: 'Rejection is protection sometimes.', by: 'Unknown' },
                    { ko: '       .', en: 'Great spirits have always encountered violent opposition from mediocre minds.', by: 'Albert Einstein, 1940' }
                ]
            },
            ACCLAIM: {
                title: 'ACCLAIM', tone: 'p',
                quotes: [
                    { ko: '   .    .', en: 'Success is the result of good judgment. Good judgment is the result of experience.', by: 'Tony Robbins' },
                    { ko: '   .    .', en: 'It is not the critic who counts; the credit belongs to the man in the arena.', by: 'Theodore Roosevelt, 1910' }
                ]
            },
            RESIDENCY: {
                title: 'RESIDENCY', tone: 'p',
                quotes: [
                    { ko: '        .', en: 'The artist exists to show the world what it has not yet seen.', by: 'Jean Sibelius' },
                    { ko: '     .', en: 'To create, one must first empty oneself.', by: 'Kazimir Malevich' }
                ]
            },
            CENSOR: {
                title: 'CENSOR', tone: 'n',
                quotes: [
                    { ko: '      .', en: 'Where they burn books, they will ultimately burn people also.', by: 'Heinrich Heine, 1820' },
                    { ko: '     .', en: 'Where censorship exists, art must also fall silent.', by: 'Ai Weiwei' }
                ]
            },
            MUSEUM: {
                title: 'MUSEUM', tone: 'p',
                quotes: [
                    { ko: '  .', en: 'A museum is a gymnasium for the imagination.', by: 'Andr Malraux' },
                    { ko: '       .', en: 'The only way for art to survive is to enter the institution.', by: 'Marcel Duchamp' }
                ]
            },
            BIENNALE: {
                title: 'BIENNALE', tone: 'p',
                quotes: [
                    { ko: '  .    .', en: 'Art has no borders, but the artist has a homeland.', by: 'Camille Pissarro' },
                    { ko: '        .', en: 'To stand on the world stage is to etch your name in history.', by: 'Marina Abramovi' }
                ]
            }
        };
        
        // ============================================================
        // AMBIGUOUS CAPTIONS (poetic, mysterious)
        // ============================================================
        const AMBIGUOUS_LINES = [
            '  ',
            '  ',
            ' ,  ',
            '  ',
            '  ',
            '  '
        ];
        
        function createMysticCaptionTexture() {
            const t = AMBIGUOUS_LINES[Math.floor(Math.random() * AMBIGUOUS_LINES.length)];
            const c = document.createElement('canvas');
            c.width = 512; c.height = 128;
            const ctx = c.getContext('2d');
            
            // Dark translucent background
            ctx.fillStyle = 'rgba(10, 12, 24, 0.85)';
            ctx.fillRect(20, 24, 472, 80);
            
            // DS border with glow
            ctx.strokeStyle = '#3B82F6';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 24, 472, 80);
            
            // Glow effect
            ctx.shadowColor = '#3B82F6';
            ctx.shadowBlur = 15;
            
            // Text
            ctx.font = 'italic 36px "Playfair Display", serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(t, 256, 64);
            
            return new THREE.CanvasTexture(c);
        }

        // ============================================================
        // THREE.JS SETUP
        // ============================================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.BG);
        scene.fog = new THREE.FogExp2(COLORS.BG, 0.025);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 400);
        camera.position.set(0, 8, 18);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // ============================================================
        // LIGHTING
        // ============================================================
        const hemiLight = new THREE.HemisphereLight(0x444488, 0x000000, 0.6);
        scene.add(hemiLight);
        
        const dirLight = new THREE.DirectionalLight(0xaaccff, 1.5); 
        dirLight.position.set(-20, 40, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        dirLight.shadow.bias = -0.0005;
        scene.add(dirLight);
        scene.add(dirLight.target);
        
        const pointLight = new THREE.PointLight(0x3B82F6, 0.5, 50);
        pointLight.position.set(0, 5, 0);
        scene.add(pointLight);

        // ============================================================
        // POST PROCESSING (Subtle Bloom - Editorial Style)
        // ============================================================
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            0.8, 0.3, 0.9
        );
        bloom.threshold = 0.8;
        bloom.strength = 0.15;
        bloom.radius = 0.3;
        composer.addPass(bloom);

        // ============================================================
        // PHASE 2.1: ENHANCED GALAXY (Layered Stars)
        // ============================================================
        function createEnhancedGalaxy() {
            const galaxyGroup = new THREE.Group();
            
            // Layer 1: Bright stars (close)
            const brightStarGeo = new THREE.BufferGeometry();
            const brightStarPos = [];
            for(let i=0; i<500; i++) {
                brightStarPos.push(
                    (Math.random()-0.5)*300,
                    Math.random()*80 + 20,
                    (Math.random()-0.5)*250
                );
            }
            brightStarGeo.setAttribute('position', new THREE.Float32BufferAttribute(brightStarPos, 3));
            const brightStars = new THREE.Points(brightStarGeo, new THREE.PointsMaterial({
                color: 0xffffff, size: 0.5, transparent: true, opacity: 0.6, sizeAttenuation: true
            }));
            galaxyGroup.add(brightStars);
            
            // Layer 2: Medium stars
            const midStarGeo = new THREE.BufferGeometry();
            const midStarPos = [];
            for(let i=0; i<1000; i++) {
                midStarPos.push(
                    (Math.random()-0.5)*400,
                    Math.random()*100 + 30,
                    (Math.random()-0.5)*350
                );
            }
            midStarGeo.setAttribute('position', new THREE.Float32BufferAttribute(midStarPos, 3));
            const midStars = new THREE.Points(midStarGeo, new THREE.PointsMaterial({
                color: 0xaaddff, size: 0.3, transparent: true, opacity: 0.5, sizeAttenuation: true
            }));
            galaxyGroup.add(midStars);
            
            // Layer 3: Dim stars (far)
            const dimStarGeo = new THREE.BufferGeometry();
            const dimStarPos = [];
            for(let i=0; i<2000; i++) {
                dimStarPos.push(
                    (Math.random()-0.5)*500,
                    Math.random()*120 + 40,
                    (Math.random()-0.5)*400
                );
            }
            dimStarGeo.setAttribute('position', new THREE.Float32BufferAttribute(dimStarPos, 3));
            const dimStars = new THREE.Points(dimStarGeo, new THREE.PointsMaterial({
                color: 0x6688cc, size: 0.12, transparent: true, opacity: 0.3, sizeAttenuation: true
            }));
            galaxyGroup.add(dimStars);
            
            // Nebula clouds (subtle colored regions)
            const nebulaGeo = new THREE.BufferGeometry();
            const nebulaPos = [];
            const nebulaColors = [];
            for(let i=0; i<300; i++) {
                nebulaPos.push(
                    (Math.random()-0.5)*200,
                    Math.random()*60 + 40,
                    (Math.random()-0.5)*150 - 100
                );
                // Purple/blue/cyan nebula colors
                const hue = 0.6 + Math.random() * 0.2;
                const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
                nebulaColors.push(color.r, color.g, color.b);
            }
            nebulaGeo.setAttribute('position', new THREE.Float32BufferAttribute(nebulaPos, 3));
            nebulaGeo.setAttribute('color', new THREE.Float32BufferAttribute(nebulaColors, 3));
            const nebula = new THREE.Points(nebulaGeo, new THREE.PointsMaterial({
                size: 2.5, transparent: true, opacity: 0.08, 
                vertexColors: true, sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            }));
            galaxyGroup.add(nebula);
            
            return galaxyGroup;
        }
        
        const galaxyGroup = createEnhancedGalaxy();
        scene.add(galaxyGroup);

        // ============================================================
        // ENVIRONMENT
        // ============================================================
        const mapTex = createMapTexture();
        const mapPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(400, 400),
            new THREE.MeshBasicMaterial({ 
                map: mapTex, 
                color: 0x8888ff,
                transparent: true,
                opacity: 0.3
            })
        );
        mapPlane.rotation.x = -Math.PI/2;
        mapPlane.position.y = -8;
        scene.add(mapPlane);

        // ============================================================
        // PHASE 2.2: ENHANCED WATER SHADER
        // ============================================================
        const waterUniforms = {
            uTime: { value: 0 },
            uColor1: { value: new THREE.Color(0x0a1a3a) },
            uColor2: { value: new THREE.Color(0x1a4a8a) }
        };
        
        const waterMaterial = new THREE.ShaderMaterial({
            uniforms: waterUniforms,
            vertexShader: `
                varying vec2 vUv;
                varying float vWave;
                uniform float uTime;
                
                void main() {
                    vUv = uv;
                    vec3 pos = position;
                    
                    // Multi-frequency waves
                    float wave1 = sin(pos.x * 0.08 + uTime * 0.8) * 0.5;
                    float wave2 = cos(pos.y * 0.06 + uTime * 0.6) * 0.4;
                    float wave3 = sin((pos.x + pos.y) * 0.05 + uTime * 1.2) * 0.3;
                    
                    pos.z += wave1 + wave2 + wave3;
                    vWave = (wave1 + wave2 + wave3) / 1.2;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                varying float vWave;
                uniform float uTime;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                
                void main() {
                    // Base color with wave influence
                    vec3 color = mix(uColor1, uColor2, vWave * 0.5 + 0.5);
                    
                    // Caustic-like pattern
                    float caustic = sin(vUv.x * 30.0 + uTime) * sin(vUv.y * 30.0 + uTime * 0.7) * 0.1;
                    color += vec3(caustic * 0.5, caustic * 0.7, caustic);
                    
                    // Fresnel-like edge highlight
                    float fresnel = pow(1.0 - abs(vWave), 3.0) * 0.3;
                    color += vec3(0.2, 0.4, 0.8) * fresnel;
                    
                    gl_FragColor = vec4(color, 0.85);
                }
            `,
            transparent: true,
            side: THREE.FrontSide
        });
        
        const waterGeo = new THREE.PlaneGeometry(400, 400, 128, 128);
        const water = new THREE.Mesh(waterGeo, waterMaterial);
        water.rotation.x = -Math.PI/2;
        water.position.y = -2;
        water.receiveShadow = true;
        scene.add(water);

        // ============================================================
        // MYSTIC ISLES (3 treasure islands with light shafts)
        // ============================================================
        function createLightCone(colorHex) {
            const g = new THREE.ConeGeometry(8, 80, 24, 1, true);
            const m = new THREE.MeshBasicMaterial({ 
                color: colorHex, 
                transparent: true, 
                opacity: 0.08, 
                blending: THREE.AdditiveBlending, 
                side: THREE.DoubleSide 
            });
            const cone = new THREE.Mesh(g, m);
            cone.position.y = 20;
            cone.rotation.x = -Math.PI / 2.1; // Angled shafts like god rays
            return cone;
        }
        
        function createRock() {
            const g = new THREE.IcosahedronGeometry(5, 1); // Low-poly rock
            const m = new THREE.MeshStandardMaterial({ 
                color: 0x30343f, 
                roughness: 0.9, 
                metalness: 0.0 
            });
            const mesh = new THREE.Mesh(g, m);
            mesh.castShadow = true;
            mesh.position.y = -1.5;
            return mesh;
        }
        
        function createMysticIsle(colorHex) {
            const isle = new THREE.Group();
            
            // Primary light cone
            const coneA = createLightCone(colorHex);
            coneA.scale.set(1.0, 1.0, 1.0);
            
            // Secondary light cone (offset for depth)
            const coneB = createLightCone(colorHex);
            coneB.scale.set(0.7, 0.7, 0.7);
            coneB.rotation.z = 0.4;
            
            // Rock silhouette
            const rock = createRock();
            
            isle.add(coneA, coneB, rock);
            return isle;
        }
        
        // Create 3 mystic isles with blue monochrome gradient (DS palette)
        const isleColors = [0x28317C, 0x3B82F6, 0x38BDF8]; // Deep Royal, Azure, Light Blue
        const mysticIsles = [
            createMysticIsle(isleColors[0]),
            createMysticIsle(isleColors[1]),
            createMysticIsle(isleColors[2])
        ];
        
        // Position isles on the horizon
        [-40, 0, 40].forEach((x, i) => {
            const g = mysticIsles[i];
            g.position.set(x, 0, -180);
            scene.add(g);
            
            // Add poetic caption above each isle
            const captionMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(9, 2),
                new THREE.MeshBasicMaterial({ 
                    map: createMysticCaptionTexture(), 
                    transparent: true 
                })
            );
            captionMesh.position.set(0, 8, 2);
            captionMesh.renderOrder = 10;
            g.add(captionMesh);
        });

        // ============================================================
        // PLAYER SHIP
        // ============================================================
        function createLegoShip() {
            const ship = new THREE.Group();
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            
            const matBlue = new THREE.MeshStandardMaterial({ color: 0x1e3a8a, roughness: 0.2 }); 
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 }); 
            const matRed = new THREE.MeshStandardMaterial({ color: 0xdc2626, roughness: 0.2, emissive: 0x330000 }); 
            const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 }); 
            const matSail = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, side: THREE.DoubleSide });

            // Hull
            const hullBase = new THREE.Mesh(boxGeo, matBlue);
            hullBase.scale.set(1.5, 0.8, 4);
            hullBase.position.y = 0.4;
            hullBase.castShadow = true;
            ship.add(hullBase);
            
            const hullFront = new THREE.Mesh(boxGeo, matBlue);
            hullFront.scale.set(1.5, 0.8, 1);
            hullFront.position.set(0, 0.6, -2.2);
            hullFront.rotation.x = -0.3;
            hullFront.castShadow = true;
            ship.add(hullFront);

            const hullBack = new THREE.Mesh(boxGeo, matBlue);
            hullBack.scale.set(1.5, 1.2, 1);
            hullBack.position.set(0, 0.6, 2.2);
            hullBack.castShadow = true;
            ship.add(hullBack);

            // Deck
            const deck = new THREE.Mesh(boxGeo, matWhite);
            deck.scale.set(1.7, 0.4, 4.2);
            deck.position.y = 1.0;
            deck.castShadow = true;
            ship.add(deck);

            const trim = new THREE.Mesh(boxGeo, matRed);
            trim.scale.set(1.8, 0.1, 4.3);
            trim.position.y = 0.8;
            ship.add(trim);

            // Cabin
            const cabin = new THREE.Mesh(boxGeo, matWhite);
            cabin.scale.set(1.4, 1.0, 1.2);
            cabin.position.set(0, 1.6, 1.5);
            cabin.castShadow = true;
            ship.add(cabin);
            
            const cabinRoof = new THREE.Mesh(boxGeo, matBlue);
            cabinRoof.scale.set(1.6, 0.2, 1.4);
            cabinRoof.position.set(0, 2.2, 1.5);
            ship.add(cabinRoof);

            // Mast & Sails
            const mast = new THREE.Mesh(boxGeo, matBlack);
            mast.scale.set(0.2, 5, 0.2);
            mast.position.set(0, 3, -0.5);
            mast.castShadow = true;
            ship.add(mast);

            const nest = new THREE.Mesh(boxGeo, matRed);
            nest.scale.set(0.6, 0.4, 0.6);
            nest.position.set(0, 4.5, -0.5);
            ship.add(nest);

            const yardMain = new THREE.Mesh(boxGeo, matBlack);
            yardMain.scale.set(3, 0.1, 0.1);
            yardMain.position.set(0, 4, -0.5);
            ship.add(yardMain);

            const sailMain = new THREE.Mesh(new THREE.PlaneGeometry(2.8, 2), matSail);
            sailMain.position.set(0, 3, -0.4);
            sailMain.rotation.x = 0.1;
            sailMain.castShadow = true;
            ship.add(sailMain);

            const jibGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 4, -0.5),
                new THREE.Vector3(0, 1, -3),
                new THREE.Vector3(0, 1, -0.5)
            ]);
            const jib = new THREE.Mesh(jibGeo, matSail);
            jib.castShadow = true;
            ship.add(jib);

            // Flag
            const flagPole = new THREE.Mesh(boxGeo, matBlack);
            flagPole.scale.set(0.05, 1, 0.05);
            flagPole.position.set(0, 5.8, -0.5);
            ship.add(flagPole);
            
            const flag = new THREE.Mesh(boxGeo, matRed);
            flag.scale.set(0.05, 0.4, 0.6);
            flag.position.set(0, 5.8, -0.8);
            ship.add(flag);

            return ship;
        }

        const playerGroup = createLegoShip();
        scene.add(playerGroup);

        // ============================================================
        // REUSABLE GEOMETRIES & MATERIALS
        // ============================================================
        const GEO_DODECA = new THREE.DodecahedronGeometry(1.0);
        const GEO_BOX = new THREE.BoxGeometry(1.3, 1.3, 1.3);
        const GEO_TETRA = new THREE.TetrahedronGeometry(1.0);
        const GEO_ARROW = new THREE.ConeGeometry(0.25, 0.6, 8);
        const GEO_RING = new THREE.TorusGeometry(1.4, 0.08, 8, 32);
        const GEO_GATE_FRAME = new THREE.BoxGeometry(7, 10, 1);
        const GEO_GATE_HOLE = new THREE.PlaneGeometry(5, 8);
        
        // Tier materials with emissive for glow
        const MAT_TIER1 = new THREE.MeshStandardMaterial({ 
            color: COLORS.INSTITUTION, metalness: 0.8, roughness: 0.2, 
            emissive: 0x111144, emissiveIntensity: 0.5 
        });
        const MAT_TIER2 = new THREE.MeshStandardMaterial({ 
            color: COLORS.NETWORK, metalness: 0.8, roughness: 0.2, 
            emissive: 0x002255, emissiveIntensity: 0.5 
        });
        const MAT_TIER3 = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, metalness: 0.9, roughness: 0.1, 
            emissive: 0x333333, emissiveIntensity: 0.3 
        });
        const MAT_ARROW = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, emissive: 0x3B82F6, emissiveIntensity: 1.0 
        });
        const MAT_RING = new THREE.MeshBasicMaterial({ 
            color: 0x3B82F6, transparent: true, opacity: 0.6 
        });
        const MAT_WIRE = new THREE.MeshBasicMaterial({ color: 0x3B82F6, wireframe: true });

        // ============================================================
        // PHASE 1.2: HIT PARTICLE SYSTEM
        // ============================================================
        class HitParticleSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 500;
                
                // Pre-allocate geometry
                this.positions = new Float32Array(this.maxParticles * 3);
                this.velocities = new Float32Array(this.maxParticles * 3);
                this.lifetimes = new Float32Array(this.maxParticles);
                this.colors = new Float32Array(this.maxParticles * 3);
                
                this.geometry = new THREE.BufferGeometry();
                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                
                this.material = new THREE.PointsMaterial({
                    size: 0.25,
                    transparent: true,
                    opacity: 0.9,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
                
                this.activeCount = 0;
            }
            
            emit(position, color = new THREE.Color(0x3B82F6), count = 25) {
                for (let i = 0; i < count && this.activeCount < this.maxParticles; i++) {
                    const idx = this.activeCount;
                    
                    // Position
                    this.positions[idx * 3] = position.x;
                    this.positions[idx * 3 + 1] = position.y;
                    this.positions[idx * 3 + 2] = position.z;
                    
                    // Random velocity (spherical explosion)
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const speed = 2 + Math.random() * 4;
                    this.velocities[idx * 3] = Math.sin(phi) * Math.cos(theta) * speed;
                    this.velocities[idx * 3 + 1] = Math.cos(phi) * speed + 2; // Bias upward
                    this.velocities[idx * 3 + 2] = Math.sin(phi) * Math.sin(theta) * speed;
                    
                    // Color with slight variation
                    const hsl = {};
                    color.getHSL(hsl);
                    const variedColor = new THREE.Color().setHSL(
                        hsl.h + (Math.random() - 0.5) * 0.1,
                        hsl.s,
                        hsl.l + Math.random() * 0.2
                    );
                    this.colors[idx * 3] = variedColor.r;
                    this.colors[idx * 3 + 1] = variedColor.g;
                    this.colors[idx * 3 + 2] = variedColor.b;
                    
                    // Lifetime
                    this.lifetimes[idx] = 0.5 + Math.random() * 0.5;
                    
                    this.activeCount++;
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
            }
            
            update(dt) {
                for (let i = this.activeCount - 1; i >= 0; i--) {
                    this.lifetimes[i] -= dt;
                    
                    if (this.lifetimes[i] <= 0) {
                        // Remove particle by swapping with last
                        this.activeCount--;
                        if (i < this.activeCount) {
                            this.positions[i * 3] = this.positions[this.activeCount * 3];
                            this.positions[i * 3 + 1] = this.positions[this.activeCount * 3 + 1];
                            this.positions[i * 3 + 2] = this.positions[this.activeCount * 3 + 2];
                            this.velocities[i * 3] = this.velocities[this.activeCount * 3];
                            this.velocities[i * 3 + 1] = this.velocities[this.activeCount * 3 + 1];
                            this.velocities[i * 3 + 2] = this.velocities[this.activeCount * 3 + 2];
                            this.colors[i * 3] = this.colors[this.activeCount * 3];
                            this.colors[i * 3 + 1] = this.colors[this.activeCount * 3 + 1];
                            this.colors[i * 3 + 2] = this.colors[this.activeCount * 3 + 2];
                            this.lifetimes[i] = this.lifetimes[this.activeCount];
                        }
                    } else {
                        // Update position
                        this.positions[i * 3] += this.velocities[i * 3] * dt;
                        this.positions[i * 3 + 1] += this.velocities[i * 3 + 1] * dt;
                        this.positions[i * 3 + 2] += this.velocities[i * 3 + 2] * dt;
                        
                        // Gravity
                        this.velocities[i * 3 + 1] -= 9.8 * dt;
                        
                        // Fade out (darken color)
                        const fade = this.lifetimes[i] / 1.0;
                        this.colors[i * 3] *= (1 - dt * 2);
                        this.colors[i * 3 + 1] *= (1 - dt * 2);
                        this.colors[i * 3 + 2] *= (1 - dt * 2);
                    }
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.setDrawRange(0, this.activeCount);
            }
        }
        
        const hitParticles = new HitParticleSystem();

        // Screen flash effect
        function triggerHitFlash() {
            const flash = document.getElementById('hit-flash');
            flash.classList.add('flash');
            setTimeout(() => flash.classList.remove('flash'), 100);
        }

        // ============================================================
        // PHASE 1.1: ENHANCED ARTIFACT (Directional Notes)
        // ============================================================
        class Artifact {
            constructor() {
                this.mesh = new THREE.Group();
                this.active = false;
                this.pts = 0;
                this.tier = 1;
                this.direction = 'ANY';
                this.directionVector = new THREE.Vector3();
                this.ringMesh = null;
                this.arrowMesh = null;
                this.baseMesh = null;
                this.pulsePhase = Math.random() * Math.PI * 2;
                scene.add(this.mesh);
            }
            
            spawn(z) {
                this.mesh.clear();
                
                // Determine tier and direction
                const r = Math.random();
                let geo, mat;
                
                if (r > 0.75) { 
                    geo = GEO_DODECA; mat = MAT_TIER1; 
                    this.pts = 10; this.tier = 1;
                } else if (r > 0.35) {
                    geo = GEO_BOX; mat = MAT_TIER2; 
                    this.pts = 5; this.tier = 2;
                } else {
                    geo = GEO_TETRA; mat = MAT_TIER3; 
                    this.pts = 2; this.tier = 3;
                }
                
                // Wireframe variant
                if (Math.random() < 0.1) { 
                    mat = MAT_WIRE; 
                    this.pts = 8; 
                }
                
                // Random direction (or ANY for simple collection)
                const dirKey = DIRECTION_KEYS[Math.floor(Math.random() * DIRECTION_KEYS.length)];
                this.direction = dirKey;
                this.directionVector.copy(DIRECTIONS[dirKey].vector);

                // Base mesh
                this.baseMesh = new THREE.Mesh(geo, mat);
                this.baseMesh.castShadow = true;
                this.mesh.add(this.baseMesh);
                
                // Glow ring
                this.ringMesh = new THREE.Mesh(GEO_RING, MAT_RING.clone());
                this.ringMesh.rotation.x = Math.PI / 2;
                this.mesh.add(this.ringMesh);
                
                // Direction arrow (if not ANY)
                if (this.direction !== 'ANY') {
                    this.arrowMesh = new THREE.Mesh(GEO_ARROW, MAT_ARROW.clone());
                    this.arrowMesh.position.y = 1.8;
                    this.arrowMesh.rotation.z = DIRECTIONS[this.direction].rotation;
                    
                    // Adjust arrow position based on direction
                    if (this.direction === 'LEFT') {
                        this.arrowMesh.position.set(-1.5, 0, 0);
                        this.arrowMesh.rotation.z = Math.PI / 2;
                    } else if (this.direction === 'RIGHT') {
                        this.arrowMesh.position.set(1.5, 0, 0);
                        this.arrowMesh.rotation.z = -Math.PI / 2;
                    } else if (this.direction === 'UP') {
                        this.arrowMesh.position.set(0, 1.5, 0);
                        this.arrowMesh.rotation.z = 0;
                    } else if (this.direction === 'DOWN') {
                        this.arrowMesh.position.set(0, -1.5, 0);
                        this.arrowMesh.rotation.z = Math.PI;
                    }
                    
                    this.mesh.add(this.arrowMesh);
                }
                
                // Position
                this.mesh.position.set((Math.random() - 0.5) * 24, 2, z);
                this.active = true;
                this.mesh.visible = true;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }
            
            update(dt, now) {
                if (!this.active) return;
                
                this.mesh.position.z += state.speed * dt;
                
                // Rotation
                this.mesh.rotation.x += dt * 0.5;
                this.mesh.rotation.y += dt * 0.8;
                
                // Floating animation
                this.mesh.position.y = 2 + Math.sin(now * 2 + this.pulsePhase) * 0.5;
                
                // Ring pulse
                if (this.ringMesh) {
                    const pulse = 1 + Math.sin(now * 4 + this.pulsePhase) * 0.1;
                    this.ringMesh.scale.setScalar(pulse);
                    this.ringMesh.material.opacity = 0.4 + Math.sin(now * 3) * 0.2;
                }
                
                // Arrow glow pulse
                if (this.arrowMesh) {
                    this.arrowMesh.material.emissiveIntensity = 0.8 + Math.sin(now * 5) * 0.4;
                }
                
                // Despawn
                if (this.mesh.position.z > 15) {
                    this.active = false;
                    this.mesh.visible = false;
                    // Miss - reset combo
                    comboSystem.resetCombo();
                }
            }
            
            collect() {
                if (!this.active) return 0;
                
                this.active = false;
                this.mesh.visible = false;
                
                // Emit particles based on tier
                const color = this.tier === 1 ? new THREE.Color(0x28317C) :
                              this.tier === 2 ? new THREE.Color(0x3B82F6) :
                              new THREE.Color(0xffffff);
                hitParticles.emit(this.mesh.position.clone(), color, 20 + this.tier * 10);
                
                // Flash effect
                triggerHitFlash();
                
                // Update combo and calculate score
                const multiplier = comboSystem.addHit();
                
                // Play collect sound with rhythm bonus check
                if (audioSystem.isOnBeat(150)) {
                    audioSystem.playPerfectHit();
                } else {
                    audioSystem.playCollectSound(this.tier, comboSystem.combo);
                }
                
                return comboSystem.getScore(this.pts);
            }
        }

        // ============================================================
        // PHASE 3.1: ENHANCED GATE (Portal Shader)
        // ============================================================
        const portalUniforms = {
            uTime: { value: 0 },
            uColor1: { value: new THREE.Color(0x28317C) },
            uColor2: { value: new THREE.Color(0x3B82F6) }
        };
        
        const portalMaterial = new THREE.ShaderMaterial({
            uniforms: portalUniforms,
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                varying vec2 vUv;
                
                void main() {
                    vec2 center = vUv - 0.5;
                    float angle = atan(center.y, center.x) + uTime * 2.0;
                    float radius = length(center);
                    
                    // Spiral pattern
                    float spiral = sin(angle * 5.0 - radius * 15.0 + uTime * 3.0) * 0.5 + 0.5;
                    
                    // Radial gradient
                    float radialGrad = 1.0 - smoothstep(0.0, 0.5, radius);
                    
                    // Color mixing
                    vec3 color = mix(uColor1, uColor2, spiral);
                    color += vec3(0.1, 0.2, 0.4) * radialGrad;
                    
                    // Vignette
                    float alpha = radialGrad * (0.7 + spiral * 0.3);
                    
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });

        class Gate {
            constructor() {
                this.mesh = new THREE.Group();
                this.active = false;
                this.label = "";
                this.isNegative = false;
                this.portalMesh = null;
                scene.add(this.mesh);
            }
            
            spawn(z, x, labelData) {
                this.mesh.clear();
                this.label = labelData.l;
                this.isNegative = labelData.t === 'n';
                
                // Frame material
                const frameMat = this.isNegative ? 
                    new THREE.MeshStandardMaterial({ 
                        color: 0x550000, roughness: 0.2, 
                        emissive: 0x220000, emissiveIntensity: 0.5 
                    }) : 
                    new THREE.MeshStandardMaterial({ 
                        color: 0x222244, roughness: 0.2,
                        emissive: 0x111133, emissiveIntensity: 0.3
                    });
                
                // Frame
                const frame = new THREE.Mesh(GEO_GATE_FRAME, frameMat);
                frame.castShadow = true;
                this.mesh.add(frame);
                
                // Portal effect (instead of black hole)
                const portalGeo = new THREE.PlaneGeometry(5, 8);
                const portalMat = portalMaterial.clone();
                if (this.isNegative) {
                    portalMat.uniforms.uColor1.value = new THREE.Color(0x550000);
                    portalMat.uniforms.uColor2.value = new THREE.Color(0xff2222);
                }
                this.portalMesh = new THREE.Mesh(portalGeo, portalMat);
                this.portalMesh.position.z = 0.1;
                this.mesh.add(this.portalMesh);
                
                // Mystic caption (hide actual label, reveal on entry)
                const textTex = createMysticCaptionTexture();
                const textMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(6, 1.5), 
                    new THREE.MeshBasicMaterial({ map: textTex, transparent: true })
                );
                textMesh.position.set(0, 3.5, 0.6);
                this.mesh.add(textMesh);
                
                // Position
                this.mesh.position.set(x, 2, z);
                this.active = true;
                this.mesh.visible = true;
            }
            
            update(dt, now) {
                if (!this.active) return;
                
                this.mesh.position.z += state.speed * dt;
                
                // Update portal shader time
                if (this.portalMesh && this.portalMesh.material.uniforms) {
                    this.portalMesh.material.uniforms.uTime.value = now;
                }
                
                // Despawn
                if (this.mesh.position.z > 10) {
                    this.active = false;
                    this.mesh.visible = false;
                }
            }
        }

        // ============================================================
        // GAME STATE
        // ============================================================
        const state = {
            isRunning: true, 
            isPaused: false,
            score: 0, 
            eraIndex: 0, 
            speed: 40, 
            distance: 0,
            path: [], 
            inputX: 0,
            velocity: new THREE.Vector2(0, 0),
            // Transition state
            isTransitioning: false,
            transitionStartTime: 0,
            transitionGate: null,
            originalCameraZ: 18,
            targetCameraZ: 8
        };

        // ============================================================
        // PHASE 3.2: GATE TRANSITION ANIMATION
        // ============================================================
        function initSpeedLines() {
            const container = document.getElementById('speed-lines');
            for (let i = 0; i < 20; i++) {
                const line = document.createElement('div');
                line.className = 'speed-line';
                line.style.left = `${Math.random() * 100}%`;
                line.style.animationDelay = `${Math.random() * 0.5}s`;
                line.style.opacity = `${0.3 + Math.random() * 0.7}`;
                container.appendChild(line);
            }
        }
        initSpeedLines();

        function startGateTransition(gate) {
            state.isTransitioning = true;
            state.transitionStartTime = performance.now();
            state.transitionGate = gate;
            
            // Play gate sound
            audioSystem.playGateSound(gate.isNegative);
            
            // Show transition overlay
            const overlay = document.getElementById('gate-transition');
            const labelEl = document.getElementById('transition-label');
            const eraEl = document.getElementById('transition-era');
            const choiceEl = document.getElementById('transition-choice');
            const quoteTextEl = document.getElementById('quote-text');
            const quoteAuthorEl = document.getElementById('quote-author');
            
            // Update content
            const nextEra = ERAS[state.eraIndex + 1] || 'LEGEND';
            labelEl.textContent = state.eraIndex >= 2 ? 'Career Complete' : 'Entering New Era';
            eraEl.textContent = nextEra;
            
            // Get reveal info with quote
            const info = REVEAL_INFO[gate.label] || { title: gate.label, quotes: [] };
            choiceEl.textContent = info.title;
            choiceEl.className = `transition-choice ${gate.isNegative ? 'negative' : ''}`;
            
            // Show random quote from the category
            if (info.quotes && info.quotes.length > 0) {
                const q = info.quotes[Math.floor(Math.random() * info.quotes.length)];
                quoteTextEl.textContent = `"${q.ko}"`;
                quoteAuthorEl.textContent = ` ${q.by}`;
            } else {
                quoteTextEl.textContent = '';
                quoteAuthorEl.textContent = '';
            }
            
            // Reset animations by re-adding elements
            [labelEl, eraEl, choiceEl, quoteTextEl, quoteAuthorEl].forEach(el => {
                el.style.animation = 'none';
                el.offsetHeight; // Trigger reflow
                el.style.animation = '';
            });
            
            overlay.classList.remove('fade-out');
            overlay.classList.add('active');
            
            // Hide all gates
            gates.forEach(gx => { gx.active = false; gx.mesh.visible = false; });
        }

        function updateGateTransition(now) {
            if (!state.isTransitioning) return;
            
            const elapsed = (performance.now() - state.transitionStartTime) / 1000;
            const duration = 2.5; // Total transition duration
            const progress = Math.min(elapsed / duration, 1);
            
            // Phase 1 (0-0.4): Camera zoom in
            if (progress < 0.4) {
                const zoomProgress = progress / 0.4;
                const eased = 1 - Math.pow(1 - zoomProgress, 3); // Ease out cubic
                camera.position.z = state.originalCameraZ - (state.originalCameraZ - state.targetCameraZ) * eased;
                
                // Increase FOV for speed effect
                camera.fov = 60 + 20 * eased;
                camera.updateProjectionMatrix();
                
                // Continue moving player towards gate
                if (state.transitionGate) {
                    const gateX = state.transitionGate.mesh.position.x;
                    playerGroup.position.x += (gateX - playerGroup.position.x) * 0.1;
                }
            }
            
            // Phase 2 (0.4-0.6): Hold with full overlay
            // (Overlay animation handles this)
            
            // Phase 3 (0.6-1.0): Camera zoom out + fade overlay
            if (progress >= 0.6) {
                const zoomOutProgress = (progress - 0.6) / 0.4;
                const eased = 1 - Math.pow(1 - zoomOutProgress, 2); // Ease out quad
                camera.position.z = state.targetCameraZ + (state.originalCameraZ - state.targetCameraZ) * eased;
                
                // Reset FOV
                camera.fov = 80 - 20 * eased;
                camera.updateProjectionMatrix();
                
                // Start fading out overlay at 70%
                if (progress >= 0.7) {
                    const overlay = document.getElementById('gate-transition');
                    overlay.classList.add('fade-out');
                }
            }
            
            // Complete transition
            if (progress >= 1) {
                completeGateTransition();
            }
        }

        function completeGateTransition() {
            state.isTransitioning = false;
            
            // Update game state
            state.path.push(state.transitionGate.label);
            state.eraIndex++;
            
            // Reset camera
            camera.position.z = state.originalCameraZ;
            camera.fov = 60;
            camera.updateProjectionMatrix();
            
            // Hide overlay
            const overlay = document.getElementById('gate-transition');
            setTimeout(() => {
                overlay.classList.remove('active', 'fade-out');
            }, 800);
            
            if (state.eraIndex >= 3) {
                // Game complete
                state.isRunning = false;
                audioSystem.playEraFanfare(state.eraIndex);
                document.getElementById('game-over').style.display = 'block';
                document.getElementById('final-score').innerText = state.score;
                document.getElementById('final-combo').innerText = comboSystem.maxCombo;
                
                const list = document.getElementById('path-results');
                list.innerHTML = '';
                state.path.forEach(p => {
                    const d = document.createElement('div'); 
                    d.className = 'path-step'; 
                    d.innerText = p; 
                    list.appendChild(d);
                });
            } else {
                // Continue to next era
                document.getElementById('era-display').innerText = ERAS[state.eraIndex];
                state.speed += 8;
                
                // Play era fanfare
                audioSystem.playEraFanfare(state.eraIndex - 1);
                
                // Reset player position smoothly
                playerGroup.position.x = 0;
                state.velocity.set(0, 0);
            }
            
            state.transitionGate = null;
        }

        const artifacts = [];
        const gates = [];

        for (let i = 0; i < 25; i++) artifacts.push(new Artifact());
        for (let i = 0; i < 3; i++) gates.push(new Gate());

        window.addEventListener('message', e => { 
            if (e.data?.type === 'PAUSE_GAME') state.isPaused = e.data.payload; 
        });

        // ============================================================
        // ANIMATION LOOP
        // ============================================================
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            if (state.isPaused) return;

            const dt = Math.min(clock.getDelta(), 0.1);
            const now = clock.getElapsedTime();

            // Update combo decay
            comboSystem.update();

            // Update water shader
            waterUniforms.uTime.value = now;
            
            // Update portal shaders
            portalUniforms.uTime.value = now;

            // Update particles
            hitParticles.update(dt);

            // Update gate transition animation
            updateGateTransition(now);

            if (state.isRunning && !state.isTransitioning) {
                // Get input from dual input system (MediaPipe or Keyboard)
                state.inputX = inputSystem.getInput();
                
                // Player physics
                const targetVel = state.inputX * 35;
                const accel = state.inputX !== 0 ? 3.0 : 1.5;
                state.velocity.x += (targetVel - state.velocity.x) * accel * dt;
                
                playerGroup.position.x += state.velocity.x * dt;
                playerGroup.position.x = Math.max(-18, Math.min(18, playerGroup.position.x));

                // Shadow tracking
                const lightOffset = playerGroup.position.x;
                dirLight.position.x = -20 + lightOffset; 
                dirLight.target.position.x = lightOffset;
                dirLight.target.updateMatrixWorld();

                // Player animation
                const bankAngle = -state.velocity.x * 0.015;
                playerGroup.rotation.z += (bankAngle - playerGroup.rotation.z) * 4.0 * dt;
                playerGroup.rotation.x = Math.sin(now * 1.5) * 0.05 - (state.velocity.x / 35) * 0.1;
                playerGroup.position.y = Math.sin(now * 2.5) * 0.2 - 0.5;

                // Environment scroll
                mapTex.offset.y = (now * 0.02) % 1;
                
                // Galaxy rotation (subtle)
                galaxyGroup.rotation.y = now * 0.01;
                
                // Mystic isles animation (gentle sway)
                mysticIsles.forEach((g, i) => {
                    g.rotation.y += 0.002 + i * 0.0003;
                    g.position.y = Math.sin(now * 0.5 + i * 1.2) * 0.8;
                });

                // Spawn logic
                state.distance += state.speed * dt;
                if (Math.random() < 0.05) {
                    const a = artifacts.find(x => !x.active);
                    if (a) a.spawn(-120);
                }

                // Era gates
                const ERA_LEN = 400;
                if (state.distance % ERA_LEN > ERA_LEN - 10 && !gates[0].active && state.eraIndex < 3) {
                    const era = ERAS[state.eraIndex];
                    const data = GATE_DATA[era];
                    if (data) {
                        gates[0].spawn(-150, -12, data[0]);
                        gates[1].spawn(-150, 0, data[1]);
                        gates[2].spawn(-150, 12, data[2]);
                    }
                }

                // Collisions
                const pBox = new THREE.Box3().setFromObject(playerGroup);
                pBox.min.addScalar(0.5); 
                pBox.max.subScalar(0.5);
                
                artifacts.forEach(a => {
                    a.update(dt, now);
                    if (a.active) {
                        const aBox = new THREE.Box3().setFromObject(a.mesh);
                        if (pBox.intersectsBox(aBox)) {
                            const points = a.collect();
                            state.score += points;
                            document.getElementById('score-val').innerText = state.score;
                        }
                    }
                });

                gates.forEach(g => {
                    g.update(dt, now);
                    if (g.active && !state.isTransitioning) {
                        if (Math.abs(g.mesh.position.z - playerGroup.position.z) < 2 && 
                            Math.abs(g.mesh.position.x - playerGroup.position.x) < 4) {
                            
                            // Start transition animation instead of immediate change
                            startGateTransition(g);
                        }
                    }
                });
            }
            
            composer.render();
        }
        
        animate();

        // ============================================================
        // EVENT HANDLERS
        // ============================================================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // NOTE: Keyboard input is now handled by DualInputSystem
        // The inputSystem.getInput() method handles both keyboard and hand tracking
        
        document.getElementById('restart-btn').addEventListener('click', () => {
            state.score = 0; 
            state.eraIndex = 0; 
            state.path = []; 
            state.isRunning = true; 
            state.distance = 0;
            state.speed = 40;
            state.velocity.set(0, 0);
            
            // Reset transition state
            state.isTransitioning = false;
            state.transitionGate = null;
            camera.position.z = state.originalCameraZ;
            camera.fov = 60;
            camera.updateProjectionMatrix();
            document.getElementById('gate-transition').classList.remove('active', 'fade-out');
            
            comboSystem.combo = 0;
            comboSystem.multiplier = 1;
            comboSystem.maxCombo = 0;
            comboSystem.updateUI();
            
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('era-display').innerText = '10s';
            document.getElementById('score-val').innerText = '0';
            
            artifacts.forEach(x => { x.active = false; x.mesh.visible = false; });
            gates.forEach(x => { x.active = false; x.mesh.visible = false; });
            playerGroup.position.set(0, 0, 0);
        });

        // Mobile controls (integrated with input system)
        if ('ontouchstart' in window) {
            document.getElementById('mobile-controls').style.display = 'block';
            // Hide MediaPipe indicator on mobile (touch is preferred)
            document.getElementById('input-indicator').style.display = 'none';
            
            const joy = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            let sx = 0;
            
            joy.addEventListener('touchstart', e => sx = e.touches[0].clientX);
            joy.addEventListener('touchmove', e => {
                const dx = e.touches[0].clientX - sx;
                inputSystem.keyboardInput = Math.max(-1, Math.min(1, dx / 40));
                knob.style.transform = `translate(calc(-50% + ${inputSystem.keyboardInput * 40}px), -50%)`;
            });
            joy.addEventListener('touchend', () => { 
                inputSystem.keyboardInput = 0; 
                knob.style.transform = `translate(-50%, -50%)`; 
            });
        }
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            inputSystem.destroy();
            audioSystem.dispose();
        });
        
        // Audio toggle button
        const audioToggle = document.getElementById('audio-toggle');
        const audioOnIcon = document.getElementById('audio-on-icon');
        const audioOffIcon = document.getElementById('audio-off-icon');
        
        audioToggle.addEventListener('click', () => {
            const isEnabled = audioSystem.toggleEnabled();
            audioToggle.classList.toggle('muted', !isEnabled);
            audioOnIcon.style.display = isEnabled ? 'block' : 'none';
            audioOffIcon.style.display = isEnabled ? 'none' : 'block';
        });
        
        // Beat indicator animation
        const beatIndicator = document.getElementById('beat-indicator');
        audioSystem.onBeat(() => {
            beatIndicator.classList.add('beat');
            setTimeout(() => beatIndicator.classList.remove('beat'), 150);
        });
        
        // Keyboard shortcut for audio toggle (M key)
        window.addEventListener('keydown', (e) => {
            if (e.key === 'm' || e.key === 'M') {
                audioToggle.click();
            }
        });
        
        // Show input controls hint on first load
        setTimeout(() => {
            console.log('%c[Curator\'s Run] Input Controls:', 'color: #3B82F6; font-weight: bold');
            console.log('%c- Arrow Keys or A/D: Move left/right', 'color: #888');
            console.log('%c- Press H: Toggle hand tracking mode', 'color: #888');
            console.log('%c- Click input indicator: Toggle input mode', 'color: #888');
        }, 1000);
    </script>
</body>
</html>
